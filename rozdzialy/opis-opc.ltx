\section{Opis protokołu OPC}

\subsection{Rys historyczny}

% http://www.opcconnect.com/history.php

Początków zainteresowania wymianą danych pomiędzy urządzeniami
automatyki przemysłowej i~systemami operacyjnymi ogólnego zastosowania
dopatrywać~się można w~roku 1990. Wprowadzony został wówczas na~rynek
system operacyjny Windows~3.0, posiadający podwaliny wielozadaniowości
--- możliwości pracy z~wieloma programami uruchomionymi jednocześnie,
oraz mechanizm DDE (\textit{Dynamic Data Exchange}), standaryzujący
wymianę danych pomiędzy uruchomionymi aplikacjami.

Już wówczas dostrzegano korzyści przekazywania danych procesowych
do~aplikacji ogólnego zastosowania, jak np.~arkusz kalkulacyjny.
Mechanizm DDE posiadał jednak znaczne ograniczenia. Nie~umożliwiał
chociażby przesyłu informacji pomiędzy różnymi komputerami w~obrębie
sieci komputerowej, a~jego przepustowość była silnie ograniczona.

Kilka firm podejmowało niezależne próby rozwiązania tych problemów,
oferując własne rozwiązania takie jak NetDDE i~FastDDE firmy
Wonderware czy~AdvanceDDE firmy Rockwell Software. Rozwiązania te miały
charakter własnościowy, przez co nie~miały szansy stać~się standardem
przemysłowym.

W~roku 1992 wprowadzono standard OLE 2.0 (\textit{Object Layer
Extensions 2.0}), który charakteryzował~się większą elastycznością
i~wydajnością. W~tym czasie uformowała~się również grupa WinSEM
(\textit{Windows in~Science, Engineering and~Manufacturing}),
zrzeszająca przedstawicieli firm zajmujących~się automatyką przemysłową
i~akwizycją danych pomiarowych zainteresowanych wykorzystaniem systemu
Windows.

Jednym z~obiektów zainteresowań grupy było wykorzystanie techniki OLE
dla~przekazywania danych procesowych pomiędzy programami w~czasie
rzeczywistym. Dostawcy oprogramowania SCADA dostrzegali w~tym możliwość
ustandaryzowania sposobu komunikacji pomiędzy rdzeniem aplikacji SCADA,
a~sterownikami obsługującymi urządzenia pomiarowe --- a~co za~tym idzie,
możliwości wykorzystania jednolitych sterowników urządzeń pomiarowych
dla~wszystkich programów w~systemie Windows.

W~roku 1995 uformowała~się grupa OPC Task Force (\textit{OLE for Process
Control Task Force}), której zadaniem było przygotowanie nowego
standardu wymiany informacji w~krótkim czasie. Pierwszy szkic standardu
OPC pojawił~się w~grudniu tego samego roku, natomiast 29 kwietnia
1996~r. ostatecznie wydano standard OPC w~wersji 1.0. Dalszym rozwojem
standardu zajmować miała~się niezależna organizacja typu non-profit,
OPC Foundation.

W~kolejnych latach protokół OPC był rozwijany i~rozszerzany. Zasadnicza
część standardu została przemianowana na~\textit{OPC Data Access},
i~została poszerzona o~kolejne specyfikacje, uzupełniające
funkcjonalność OPC. Najnowsze wersje poszczególnych specyfikacji
wymienione zostały w~tabeli~\ref{t-opc-classic}.

\begin{table}[ht]
	\caption{Lista specyfikacji OLE for Process Control}
	\label{t-opc-classic}

	\begin{tabular}{l l l p{8cm}}
		\toprule
			Nazwa & Wersja & Wyd. & Obszar \\
		\midrule
			Data Access & 3.00 & 2003 & ogólne koncepcje, odczyt i~zapis
				danych, subskrypcje powiadomień o zmianach \\
			Historical Data Access & 1.20 & 2003 & dostęp do~danych
				historycznych \\
			Alarms and Events & 1.1 & 2002 & monitorowanie i~zgłaszania
				sytuacji alarmowych \\
			XML-Data Access & 1.01 & 2004 & dostęp do~danych w~oparciu
				o~standard XML \\
			Data eXchange & 1.00 & 2003 & wymiana informacji pomiędzy
				serwerami OPC \\
			Complex Data & 1.00 & 2003 & wykorzystanie złożonych
				struktur danych \\
			Security & 1.00 & 2000 & metody kontroli dostępu
				do~aplikacji i~danych \\
			Batch & 2.00 & 2001 & przesył algorytmów do~urządzeń \\
		\bottomrule
	\end{tabular}
\end{table}

% http://documentation.unified-automation.com/uasdkcpp/1.0.0/L2OpcUaMotivation.html

Standard OPC zdobył dużą popularność jako otwarty, ujednolicony sposób
komunikacji pomiędzy urządzeniami automatyki i~systemami komputerowymi.
Jednakże jego podstawę stanowił zamknięty, własnościowy standard DCOM
(\textit{Distributed Common Object Model}) firmy Microsoft, co
praktycznie ograniczało możliwość zastosowania OPC do~platform opartych
o~system Windows.

Dlatego też OPC Foundation podjęło prace nad~nowym standardem OPC UA
(\textit{Open Platform Communications Unified Architecture}), które
zaowocowały wypuszczeniem pierwszej wersji jego specyfikacji w~2006~r.
Nowy standard charakteryzuje~się strukturą warstwową, która oddziela
cechy protokołu OPC od~wykorzystywanej platformy komunikacyjnej.
W~wersji 1.00 uwzględniono możliwość kodowania informacji w~otwartym
formacie XML lub~dedykowanym formacie binarnym, natomiast funkcje
komunikacyjne zrealizowano w~oparciu o~protokół TCP lub~usługi SOAP
wykorzystujące protokół HTTP.

W~latach 2010--2011 kolejne części standardu OPC UA zostały przyjęte
jako norma IEC 62541.


\subsection{Warunki licencyjne OPC UA}

Na~potrzeby podmiotów zainteresowanych implementacją OPC UA, OPC
Foundation udostępnia dwa rodzaje zasobów:

\begin{enumerate}
	\item pełną specyfikację protokołu, z~uwzględnieniem wewnętrznych
		aspektów implementacji,

	\item interfejs programistyczny (API), ułatwiający implementację OPC
		UA w~językach C, C++, Java oraz w~oparciu o~platformę .NET.
\end{enumerate}

Zasoby te udostępniane są bezpłatnie członkom OPC Foundation, jednakże
członkostwo wiąże~się ze~zobowiązaniami finansowymi. Materiały objęte są
w~pełni zastrzeżonymi prawami autorskimi, co uniemożliwia swobodną ich
dystrybucję.

% http://pl.wikipedia.org/wiki/Otwarty_standard#cite_note-1
% http://ec.europa.eu/idabc/servlets/Docd552.pdf?id=19529
% http://ec.europa.eu/idabc/en/document/2319/5644.html

Zgodnie z~definicją przedstawioną przez~Komisję Europejską w~opisie
\textit{European Interoperability Framework for pan-European
eGovernment Services version 1.0}, jednym z~warunków koniecznych
do~spełnienia przez~otwarty standard jest dostępność specyfikacji
standardu wszystkim zainteresowanym nieodpłatnie lub po~kosztach druku,
oraz prawo nieodpłatnego (lub po~kosztach druku) kopiowania,
rozpowszechniania i~użytku. W~myśl tej definicji, standard OPC UA
nie~jest otwartym standardem.


\subsection{Struktura specyfikacji OPC UA}

\begin{table}[ht]
	\caption{Lista specyfikacji OPC UA}
	\label{t-opc-ua}

	\begin{tabular}{l l l p{8cm}}
		\toprule
			Cz. & Tytuł & Wersja & Obszar \\
		\midrule
			1 & Overview and Concepts & 1.02
				& przegląd specyfikacji, celów standardu, topologii systemu \\
			2 & Security Model & 1.02
				& przegląd problematyki bezpieczeństwa, kontroli dostępu,
				audytu działań, niezawodności \\
			3 & Address Space Model & 1.02
				& koncepcja i~logiczna organizacja przestrzeni adresowej
				--- definicja węzłów, referencji; typy danych i~zdarzeń \\
			4 & Services & 1.02
				& usługi oferowane przez serwer OPC \\
			5 & Information Model & 1.02
				& szczegółowy opis węzłów, obiektów, zasady modelowania typów \\
			6 & Mappings & 1.02
				& zasady kodowania danych, mapowanie na~protokoły sieciowe \\
			7 & Profiles & 1.02
				& podział serwerów i~klientów na~kategorie, w~zależności
				od~obsługiwanej funkcjonalności, zabezpieczeń \\
			8 & Data Access & 1.02
				& \\
			9 & Alarms and~Conditions & 1.02
				& \\
			10 & Programs & 1.02
				& \\
			11 & Historical Access & 1.02
				& \\
			12 & Discovery & 1.02.38
				& odnajdywanie serwerów OPC w~sieci lokalnej oraz~globalnej \\
			13 & Aggregates & 1.02
				& \\
		\bottomrule
	\end{tabular}
\end{table}

Specyfikacja OPC UA składa~się aktualnie z~13 części, które wymienione
zostały w~tabeli~\ref{t-opc-ua}. Części 1--6 oraz~8 zostały przyjęte
w~latach 2010--2011 jako norma IEC 62541.

Części 1.--5. opisują podstawową część protokołu OPC UA w~sposób
abstrakcyjny. Definiują strukturę sieci, organizację danych i~dostępne
usługi, nie~narzucając konkretnej reprezentacji binarnej czy~sposobu
realizacji komunikacji. Części te mogą posłużyć zaprojektowaniu
i~wykonaniu implementacji stosu OPC UA wraz z~jego wewnętrznym API,
nie~zapewnią jednak współpracy pomiędzy stosami różnych producentów.

Część 6. specyfikacji definiuje standardowe sposoby kodowania danych
oraz~protokoły sieciowe dla~OPC. Na~jej podstawie do~zdefiniowanych
w~poprzednich częściach, abstrakcyjnych typów danych przypisywane
zostają algorytmy serializacji, a~następnie definiowane są protokoły
sieciowe, które umożliwiają przesyłanie do~serwera OPC żądań
i~otrzymywanie odpowiedzi.

Zdefiniowane zostały dwa standardowe sposoby kodowania danych ---
kodowanie binarne oraz~za~pomocą języka XML, oraz~dwa standardowe
protokoły sieciowe --- binarny protokół OPC UA TCP oraz~sposób
wykorzystania transportu HTTP/SOAP. Serwer OPC UA może udostępniać swoje
zasoby przy wykorzystaniu wielu dostępnych protokołów.

Część 7. specyfikacji grupuje serwery OPC w~tzw.~profile. Poszczególne
profile określają wymagania w~stosunku do~zaimplementowanej części
specyfikacji.

Część 8. i~kolejne części specyfikacji określają dodatkowe struktury
danych i~usługi, zbudowane w~oparciu o~bazowe typy zdefiniowane
w~częściach 1.--5. Abstrakcja typów pozwala na~implementację tych części
specyfikacji bez~konieczności definiowania dedykowanego sposobu
kodowania danych --- ich realizacja wykonana może być w~oparciu o~reguły
dla~typów podstawowych określone w~6.~części specyfikacji.


\subsection{Struktura sieci OPC UA}

Protokół OPC UA oparty jest na~architekturze klient-serwer. Serwery
stanowią węzły sieci pomiarowej, współpracując z~fizycznymi urządzeniami
pomiarowymi oraz~sterującymi. Każdy serwer definiuje przestrzeń
adresową, w~obrębie której zamodelowane są poszczególne obiekty.

Z~każdym serwerem połączonych może być wielu klientów. Klienci ---
w~zależności od~przypisanych uprawnień --- mogą wykonywać określone
operacje na~węzłach przestrzeni adresowej serwera. Do~typowych operacji
należą:

\begin{itemize}
	\item odczyt bieżących i~historycznych danych pomiarowych,

	\item odczyt i~modyfikacja danych sterujących procesami,

	\item monitorowanie zmian danych pomiarowych.
\end{itemize}

Serwer może również pełnić rolę klienta w~stosunku do~innych serwerów
OPC UA. W~ten sposób we~własnej przestrzeni adresowej może odwzorować
fragmenty przestrzeni adresowych innych serwerów, umożliwiając klientom
pośredni dostęp do~oferowanych przez~nie danych. Pozwala to na~budowanie
sieci pomiarowych o~praktycznie dowolnej strukturze.


\subsection{Przestrzeń adresowa OPC UA}

Przestrzeń adresowa stanowi logiczną organizację zasobów serwera
OPC UA. Poszczególne zasoby modelowane są w~postaci węzłów. Węzły mogą
reprezentować m.in.:

\begin{enumerate}
	\item zmienne, stanowiące wynik pomiaru bądź~zmienne sterowania,

	\item obiekty, służące do~organizacji logicznej struktury
	poszczególnych obiektów monitorowanych,

	\item metody, umożliwiające zdalne uruchamianie procesów i~funkcji,

	\item typy danych i~elementy struktury protokołu OPC UA.
\end{enumerate}

W~szczególności zauważyć można, że~protokół OPC UA jest silnie
introspektywny --- przestrzeń adresowa zawiera nie~tylko zasoby serwera,
ale~również opisy tych zasobów i~elementów protokołu. Umożliwia to
tworzenie uniwersalnego oprogramowania, które wykorzystując te dane jest
w~stanie prezentować i~wykorzystywać nieznane zasoby, włączając w~to
rozwiązania niestandardowe.

% TODO: przykład

Protokół OPC nie~wprowadza ograniczeń co do~rodzaju zasobów ani~sposobu
pozyskiwania wartości ich atrybutów. Co za~tym idzie, w~przestrzeni
adresowej modelowane mogą być:

\begin{enumerate}
	\item lokalne zasoby sprzętowe i~programowe, jak np.~wielkości
	mierzone przez~urządzenia pomiarowe połączone z~serwerem,

	\item lokalne zasoby wirtualne, jak np.~wielkości obliczeniowe,

	\item zdalne zasoby udostępnione przez~inne serwery OPC UA bądź
	innych protokołów sieciowych.
\end{enumerate}

Węzły w~przestrzeni adresowej adresowane są przy~pomocy identyfikatorów,
które są unikalne w~obrębie jednego serwera OPC UA. W~sieci
składającej~się z~wielu współpracujących serwerów możliwe jest
zastosowanie jednolitego modelu adresowania węzłów --- wówczas
identyfikatory są unikalne w~obrębie sieci, a~adresowanie danego zasobu
odbywa~się przy~pomocy tego samego identyfikatora niezależnie od~tego,
czy jest on zasobem zdalnym czy~lokalnym.

Węzły połączone są w~strukturę grafu za~pomocą referencji. Referencje
wykorzystywane są do~powiązania węzłów reprezentujących:

\begin{enumerate}
	\item zmienne, metody i~właściwości obiektów,

	\item obiekty podrzędne (nadrzędzne) w~strukturze
	hierarchicznej,

	\item węzły definicji typów,

	\item typy (klasy) nadrzędne i~podrzędne.
\end{enumerate}

Węzły posiadają szereg atrybutów zdefiniowanych w~obrębie specyfikacji.
Atrybuty są ściśle określone i~przypisane do~poszczególnych rodzajów
węzłów. Atrybuty wykorzystywane są jedynie do~określania ogólnych
właściwości węzłów (jak identyfikator, nazwa czy~wartość);
do~modelowania szczegółowych cech wykorzystuje~się zmienne
i~właściwości, związane z~węzłem za~pomocą referencji.


\subsection{Zapewnienie zgodności pomiędzy kolejnymi wersjami protokołu}

Mechanizm zapewnienia zgodności przy~wprowadzaniu zmian w~strukturze
protokołu OPC UA oparty jest o~mechanizm wersji. Podczas inicjacji
połączenia klient i~serwer określają wykorzystywaną przez~siebie wersję
protokołu. W~przypadku wystąpienia niezgodności, strona obsługującą
nowszą (wyższą) wersję protokołu zobowiązana jest zapewnić zgodność
z~wersją starszą.

Rozwiązanie to gwarantuje możliwość przyłączenia nowszych urządzeń
(zastosowania nowszego oprogramowania) do~istniejących sieci OPC UA
bez~konieczności wymiany bądź przeprogramowania istniejących elementów.
Nakłada jednak na~tworców oprogramowania konieczność implementacji
wszystkich poprzednich wersji protokołu.

Numery wersji przypisywane są w~toku certyfikacji oprogramowania OPC UA.
Oprogramowanie niecertyfikowane zobowiązane jest korzystać z~wersji
,,0''. Oznacza to, że~oprogramowanie nieobjęte procesem certyfikacji
nie~jest w~stanie zagwarantować prawidłowej współpracy z~oprogramowaniem
wykonanym w~oparciu o~inną wersję specyfikacji.




\subsection{Protokół OPC UA TCP}

\subsubsection{Budowa protokołu}

Opis protokołu OPC UA TCP składa~się z~trzech zasadniczych części:

\begin{enumerate}
	\item opisu kodowania standardowych typów OPC UA w~postaci binarnej
		(\textit{OPC UA Binary}),

	\item opisu sposobu nawiązania bezpiecznego połączenia (\textit{OPC
		UA Secure Conversation}),

	\item opisu wiadomości protokołu transportowego (\textit{OPC UA
		TCP}).
\end{enumerate}

Połączenie w~oparciu o~ten protokół rozpatruje~się w~trzech warstwach:

\begin{enumerate}
	\item warstwie transportowej,

	\item warstwie komunikacji (bezpiecznego połączenia),

	\item warstwie sesji.
\end{enumerate}

Zadaniem warstwy transportowej jest nawiązanie i~utrzymanie logicznego
kanału przesyłu pakietów pomiędzy klientem i~serwerem. Do~transmisji
pakietów OPC UA wykorzystuje~się parę protokołów TCP/IP. Poszczególne
pakiety poprzedzane są nagłówkiem warstwy transportowej, określającym
rodzaj pakietu oraz~jego wielkość.

Warstwa komunikacji zajmuje~się budowaniem pakietów w~oparciu
o~zakodowane binarnie wiadomości OPC UA. Do~zadań tej warstwy należy
podział wiadomości na~pakiety o~wielkości ograniczonej możliwościami
serwera (klienta), a~następnie --- o~ile jest to pożądane ---
szyfrowanie i~cyfrowy podpis pakietów.

W~odróżnieniu od~dwóch poprzednio opisanych warstw, warstwa sesji
nie~stanowi części protokołu OPC UA TCP, lecz należy do~podstawowej
specyfikacji OPC UA. Wiąże ona wiadomości przesyłane w~oparciu o~dowolny
protokół (bądź interfejs) OPC UA z~określoną sesją, w~obrębie której
obsługiwane jest uwierzytelnianie klienta oraz~obsługiwane są jego
żądania. Wyodrębnienie warstwy sesji umożliwia utrzymanie ciągłości
przesyłanych wiadomości niezależnie od~przerw w~logicznych kanałach
komunikacji.


\subsubsection{Sposób nawiązania połączenia}

\begin{figure}[h]
	\centering

	\begin{tikzpicture}
		\draw[thick] (0,0) -- ++(0,6) node[above] {klient};
		\draw[thick] (2,0) -- ++(0,6) node[above] {bezp. kanał};
		\draw[thick] (4,0) -- ++(0,6) node[above] {TCP};
		\draw[thick] (10,0) -- ++(0,6) node[above] {TCP};
		\draw[thick] (12,0) -- ++(0,6) node[above] {bezp. kanał};
		\draw[thick] (14,0) -- ++(0,6) node[above] {serwer};

		\begin{scope}[shorten >=1mm, shorten <=1mm]
			\draw[-stealth] (4,5.5) -- ++(6,0)
				node[midway, above] {nawiązanie połączenia};
			\draw[-stealth] (4,4.5) -- ++(6,0)
				node[midway, above] {wiadomość \textit{Hello}};
			\draw[stealth-] (4,3.5) -- ++(6,0)
				node[midway, above] {wiadomość \textit{Acknowledge}};
			\draw[-stealth] (2,2.5) -- ++(10,0)
				node[midway, above] {żądanie \textit{Open Secure Channel}};
			\draw[stealth-] (2,1.5) -- ++(10,0)
				node[midway, above] {odp. na~\textit{Open Secure Channel}};
			\draw[-stealth] (0,.5) -- ++(14,0)
				node[midway, above] {utworzenie/aktywacja sesji};

		\end{scope}
	\end{tikzpicture}

	\caption{Graficzne przedstawienie procedury nawiązania połączenia}
\end{figure}

Procedurę nawiązania połączenia rozpoczyna zawsze klient, poprzez
nawiązanie połączenia TCP z~serwerem. Po~nawiązaniu połączenia, klient
wysyła wiadomość \textit{Hello}, zawierającą wersję protokołu klienta,
charakterystyczne ograniczenia wielkości pakietów i~wskazania żądanego
punktu końcowego połączenia. Na~tę wiadomość serwer odpowiada
wiadomością \textit{Acknowledge} zawierającą te same informacje
o~charakterystyce serwera. Po~wymianie tych dwóch wiadomości kanał
transportowy uznaje~się za~otwarty i~pozostaje on otwarty aż
do~zakończenia połączenia TCP.

Kolejnym krokiem jest uruchomienie kanału bezpiecznego. W~tym celu
klient wysyła do~serwera żądanie \textit{Open Secure Channel},
zawierające m.in.~wskazanie sposobu zabezpieczenia wiadomości oraz~dane
niezbędne do~jego realizacji, m.in. certyfikat klienta. W~odpowiedzi
na~to żądanie serwer potwierdza otwarcie kanału bądź określa przyczynę
odmowy. W~przypadku otwarcia kanału, serwer przydziela numer kanału
oraz~klucz wykorzystywany do~symetrycznego szyfrowania dalszych
wiadomości.

Bezpieczny kanał pozostaje ważny aż~do~upływu czasu ważności klucza
bądź~do~przesłania żądania zamknięcia kanału przez~klienta. W~przypadku
zerwania połączenia TCP, klient wznawia je i~wysyła żądanie wznowienia
kanału. W~przypadku upływu czasu ważności klucza, klient wysyła żądanie
wygenerowania nowego klucza.

Ostatnią częścią procedury łączenia jest przypisanie sesji. W~celu
utworzenia nowej sesji, klient wysyła żądanie \textit{Create Session},
w~odpowiedzi na~które otrzymuje m.in.~identyfikator sesji. Następnie
wysyła żądanie \textit{Activate Session}, które powoduje przypisanie
sesji do~kanału oraz~uwierzytelnienie klienta. W~przypadku wznawiania
istniejącej sesji żadanie \textit{Create Session} pomija~się, zaś
do~żądania \textit{Activate Session} przekazuje~się dane otrzymane
po~aktywacji sesji w~poprzednim połączeniu.

Sesja pozostaje ważna do~upływu czasu ważności sesji lub~jej jawnego
zakończenia przez~klienta.
